package client

import (
	"context"
	"io"

	"github.com/aptd3v/go-contain/pkg/client/options/container/attach"
	"github.com/aptd3v/go-contain/pkg/client/options/container/checkpointcreate"
	"github.com/aptd3v/go-contain/pkg/client/options/container/checkpointdelete"
	"github.com/aptd3v/go-contain/pkg/client/options/container/checkpointlist"
	"github.com/aptd3v/go-contain/pkg/client/options/container/commit"
	"github.com/aptd3v/go-contain/pkg/client/options/container/copyto"
	"github.com/aptd3v/go-contain/pkg/client/options/container/exec"
	"github.com/aptd3v/go-contain/pkg/client/options/container/execattach"
	"github.com/aptd3v/go-contain/pkg/client/options/container/execresize"
	"github.com/aptd3v/go-contain/pkg/client/options/container/execstart"
	"github.com/aptd3v/go-contain/pkg/client/options/container/list"
	"github.com/aptd3v/go-contain/pkg/client/options/container/logs"
	"github.com/aptd3v/go-contain/pkg/client/options/container/prune"
	"github.com/aptd3v/go-contain/pkg/client/options/container/remove"
	"github.com/aptd3v/go-contain/pkg/client/options/container/start"
	"github.com/aptd3v/go-contain/pkg/client/options/container/stop"
	"github.com/aptd3v/go-contain/pkg/client/options/container/update"
	"github.com/aptd3v/go-contain/pkg/client/options/container/wait"
	"github.com/aptd3v/go-contain/pkg/client/response"
	"github.com/aptd3v/go-contain/pkg/create"
	"github.com/docker/docker/api/types/checkpoint"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/filters"
)

// ContainerCreate creates a new container based on the given configuration. It can be associated with a name, but it's not mandatory.
func (c *Client) ContainerCreate(ctx context.Context, created *create.Container) (*response.ContainerCreate, error) {
	if err := created.Validate(); err != nil {
		return nil, err
	}
	config := created.Config
	res, err := c.wrapped.ContainerCreate(
		ctx,
		config.Container,
		config.Host,
		config.Network,
		config.Platform,
		created.Name,
	)
	if err != nil {
		return nil, err
	}
	return &response.ContainerCreate{
		CreateResponse: res,
	}, nil
}

// ContainerList returns the list of containers in the docker host.
func (c *Client) ContainerList(ctx context.Context, setters ...list.SetContainerListOption) ([]response.ContainerSummary, error) {
	op := container.ListOptions{
		Filters: filters.NewArgs(),
	}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	sum, err := c.wrapped.ContainerList(ctx, op)
	if err != nil {
		return nil, err
	}
	summaries := make([]response.ContainerSummary, len(sum))
	for i, s := range sum {
		summaries[i] = response.ContainerSummary{
			Summary: s,
		}
	}
	return summaries, nil
}

// ContainerStart sends a request to the docker daemon to start a container.
func (c *Client) ContainerStart(ctx context.Context, id string, setters ...start.SetContainerStartOption) error {
	op := container.StartOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerStart(ctx, id, op)
}

// ContainerStop stops a container. In case the container fails to stop
// gracefully within a time frame specified by the timeout argument, it is forcefully terminated (killed).
func (c *Client) ContainerStop(ctx context.Context, id string, setters ...stop.SetContainerStopOption) error {
	op := container.StopOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerStop(ctx, id, op)
}

// ContainerRemove kills and removes a container from the docker host.
func (c *Client) ContainerRemove(ctx context.Context, id string, setters ...remove.SetContainerRemoveOption) error {
	op := container.RemoveOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerRemove(ctx, id, op)
}

// ContainerKill terminates the container process but does not remove the container from the docker host.
func (c *Client) ContainerKill(ctx context.Context, id string, signal string) error {
	return c.wrapped.ContainerKill(ctx, id, signal)
}

/*
ContainerLogs returns the logs generated by a container in an io.ReadCloser. It's up to the caller to close the stream.

The stream format on the response will be in one of two formats:

If the container is using a TTY, there is only a single stream (stdout), and data is copied directly from the container output stream, no extra multiplexing or headers.

If the container is *not* using a TTY, streams for stdout and stderr are multiplexed. The format of the multiplexed stream is as follows:

	[8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}[]byte{OUTPUT}

STREAM_TYPE can be 1 for stdout and 2 for stderr

SIZE1, SIZE2, SIZE3, and SIZE4 are four bytes of uint32 encoded as big endian. This is the size of OUTPUT.

You can use github.com/docker/docker/pkg/stdcopy.StdCopy to demultiplex this stream.
*/
func (c *Client) ContainerLogs(ctx context.Context, id string, setters ...logs.SetContainerLogsOption) (io.ReadCloser, error) {
	op := container.LogsOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	return c.wrapped.ContainerLogs(ctx, id, op)
}

// ContainerInspect returns the container information.
func (c *Client) ContainerInspect(ctx context.Context, id string) (*response.ContainerInspect, error) {
	inspect, err := c.wrapped.ContainerInspect(ctx, id)
	if err != nil {
		return nil, err
	}
	return &response.ContainerInspect{
		InspectResponse: inspect,
	}, nil
}

/*
ContainerWait waits until the specified container is in a certain state indicated by the given condition,
either "not-running" (default), "next-exit", or "removed". If this client's API version is before 1.30,
condition is ignored and ContainerWait will return immediately with the two channels, as the server will
wait as if the condition were "not-running".

If this client's API version is at least 1.30, ContainerWait blocks until the request has been acknowledged
by the server (with a response header), then returns two channels on which the caller can wait for the exit
status of the container or an error if there was a problem either beginning the wait request or in getting
the response. This allows the caller to synchronize ContainerWait with other calls, such as specifying a
"next-exit" condition before issuing a ContainerStart request.
*/
func (c *Client) ContainerWait(ctx context.Context, id string, condition wait.WaitCondition) (<-chan response.ContainerWait, <-chan error) {
	wait, err := c.wrapped.ContainerWait(ctx, id, container.WaitCondition(condition))
	if err != nil {
		return nil, nil
	}
	waitChan := make(chan response.ContainerWait)
	go func() {
		defer close(waitChan)
		for {
			select {
			case <-ctx.Done():
				return
			case wait := <-wait:
				waitChan <- response.ContainerWait{
					WaitResponse: wait,
				}
			}
		}
	}()
	return waitChan, nil
}

// ContainerStats returns near realtime stats for a given container.
// It's up to the caller to close the io.ReadCloser returned.
func (c *Client) ContainerStats(ctx context.Context, id string, stream bool) (*response.ContainerStatsReader, error) {
	stats, err := c.wrapped.ContainerStats(ctx, id, stream)
	if err != nil {
		return nil, err
	}
	return &response.ContainerStatsReader{
		StatsResponseReader: stats,
	}, nil
}

// ContainerExecCreate creates a new exec configuration to run an exec process.
func (c *Client) ContainerExecCreate(ctx context.Context, containerID string, setters ...exec.SetContainerExecOption) (*response.ContainerExecCreate, error) {
	op := container.ExecOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	exec, err := c.wrapped.ContainerExecCreate(ctx, containerID, op)
	if err != nil {
		return nil, err
	}
	return &response.ContainerExecCreate{
		ExecCreateResponse: exec,
	}, nil
}

// ContainerExecStart starts an exec process already created in the docker host.
func (c *Client) ContainerExecStart(ctx context.Context, execID string, setters ...execstart.SetContainerExecStartOption) error {
	op := container.ExecStartOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerExecStart(ctx, execID, op)
}

// ContainerExecResize changes the size of the tty for an exec process running inside a container.
func (c *Client) ContainerExecResize(ctx context.Context, execID string, setters ...execresize.SetContainerExecResizeOption) error {
	op := container.ResizeOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerExecResize(ctx, execID, op)
}

// ContainerExecAttach attaches a connection to an exec process in the server.
// It returns a types.HijackedConnection with the hijacked connection and the a reader to get output.
// It's up to the called to close the hijacked connection by calling types.HijackedResponse.Close.
func (c *Client) ContainerExecAttach(ctx context.Context, execID string, setters ...execattach.SetContainerExecAttachOption) (*response.ContainerHijackedResponse, error) {
	op := container.ExecAttachOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	hijacked, err := c.wrapped.ContainerExecAttach(ctx, execID, op)
	if err != nil {
		return nil, err
	}
	return &response.ContainerHijackedResponse{
		HijackedResponse: hijacked,
	}, nil
}

// ContainerRestart stops and starts a container again. It makes the daemon wait for the container to be up again for a specific amount of time, given the timeout.
func (c *Client) ContainerRestart(ctx context.Context, id string, setters ...stop.SetContainerStopOption) error {
	op := container.StopOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerRestart(ctx, id, op)
}

// ContainerPause pauses the main process of a given container without terminating it
func (c *Client) ContainerPause(ctx context.Context, id string) error {
	return c.wrapped.ContainerPause(ctx, id)
}

// ContainerUnpause resumes the process execution within a container
func (c *Client) ContainerUnpause(ctx context.Context, id string) error {
	return c.wrapped.ContainerUnpause(ctx, id)
}

// ContainersPrune requests the daemon to delete unused data
func (c *Client) ContainerPrune(ctx context.Context, setters ...prune.SetContainerPruneOption) (*response.ContainerPruneReport, error) {
	filters := filters.NewArgs()
	for _, setter := range setters {
		if setter != nil {
			if err := setter(filters); err != nil {
				return nil, err
			}
		}
	}
	prune, err := c.wrapped.ContainersPrune(ctx, filters)
	if err != nil {
		return nil, err
	}
	return &response.ContainerPruneReport{
		PruneReport: prune,
	}, nil
}

// ContainerCommit applies changes to a container and creates a new tagged image.
func (c *Client) ContainerCommit(ctx context.Context, id string, setters ...commit.SetContainerCommitOption) (*response.ContainerCommitResponse, error) {
	op := container.CommitOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	commit, err := c.wrapped.ContainerCommit(ctx, id, op)
	if err != nil {
		return nil, err
	}
	return &response.ContainerCommitResponse{
		CommitResponse: commit,
	}, nil
}

// ContainerExport retrieves the raw contents of a container and returns them as an io.ReadCloser.
// It's up to the caller to close the stream.
func (c *Client) ContainerExport(ctx context.Context, id string) (io.ReadCloser, error) {
	return c.wrapped.ContainerExport(ctx, id)
}

// ContainerDiff returns the changes on a container's filesystem.
func (c *Client) ContainerDiff(ctx context.Context, id string) ([]response.ContainerFilesystemChange, error) {
	diff, err := c.wrapped.ContainerDiff(ctx, id)
	if err != nil {
		return nil, err
	}
	changes := make([]response.ContainerFilesystemChange, len(diff))
	for i, d := range diff {
		changes[i] = response.ContainerFilesystemChange{
			FilesystemChange: d,
		}
	}
	return changes, nil
}

// ContainerUpdate updates resources of a container.
func (c *Client) ContainerUpdate(ctx context.Context, id string, setters ...update.SetContainerUpdateOption) (*response.ContainerUpdateResponse, error) {
	op := container.UpdateConfig{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	update, err := c.wrapped.ContainerUpdate(ctx, id, op)
	if err != nil {
		return nil, err
	}
	return &response.ContainerUpdateResponse{
		UpdateResponse: update,
	}, nil
}

// ContainerRename changes the name or nickname of a container.
func (c *Client) ContainerRename(ctx context.Context, id string, name string) error {
	return c.wrapped.ContainerRename(ctx, id, name)
}

// ContainerTop shows process information from within a container.
func (c *Client) ContainerTop(ctx context.Context, id string, args ...string) (*response.ContainerTopResponse, error) {
	top, err := c.wrapped.ContainerTop(ctx, id, append([]string{}, args...))
	if err != nil {
		return nil, err
	}
	return &response.ContainerTopResponse{
		TopResponse: top,
	}, nil
}

// ContainerExecInspect returns information about a specific exec process on the docker host.
func (c *Client) ContainerExecInspect(ctx context.Context, id string) (*response.ContainerExecInspect, error) {
	inspect, err := c.wrapped.ContainerExecInspect(ctx, id)
	if err != nil {
		return nil, err
	}
	return &response.ContainerExecInspect{
		ExecInspect: inspect,
	}, nil
}

// ContainerStatsOneShot gets a single stat entry from a container. It differs from
// `ContainerStats` in that the API should not wait to prime the stats
func (c *Client) ContainerStatsOneShot(ctx context.Context, id string) (*response.ContainerStatsOneShot, error) {
	stats, err := c.wrapped.ContainerStatsOneShot(ctx, id)
	if err != nil {
		return nil, err
	}
	return &response.ContainerStatsOneShot{
		StatsResponseReader: stats,
	}, nil
}

// ContainerResize changes the size of the tty for a container.
func (c *Client) ContainerResize(ctx context.Context, id string, setters ...execresize.SetContainerExecResizeOption) error {
	op := container.ResizeOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.ContainerResize(ctx, id, op)
}

// ContainerCheckpointCreate creates a checkpoint of a running container.
func (c *Client) ContainerCheckpointCreate(ctx context.Context, id string, setters ...checkpointcreate.SetContainerCheckpointCreateOption) error {
	op := checkpoint.CreateOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.CheckpointCreate(ctx, id, op)
}

// CheckpointList returns the checkpoints of the given container in the docker host
func (c *Client) ContainerCheckpointList(ctx context.Context, id string, setters ...checkpointlist.SetContainerCheckpointListOption) ([]response.ContainerCheckpointSummary, error) {
	op := checkpoint.ListOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	sum, err := c.wrapped.CheckpointList(ctx, id, op)
	if err != nil {
		return nil, err
	}
	summaries := make([]response.ContainerCheckpointSummary, len(sum))
	for i, s := range sum {
		summaries[i] = response.ContainerCheckpointSummary{
			Summary: s,
		}
	}
	return summaries, nil
}

// CheckpointDelete deletes the checkpoint with the given name from the given container
func (c *Client) ContainerCheckpointDelete(ctx context.Context, id string, setters ...checkpointdelete.SetContainerCheckpointDeleteOption) error {
	op := checkpoint.DeleteOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.CheckpointDelete(ctx, id, op)
}

// CopyToContainer copies content into the container filesystem. Note that `content` must be a Reader for a TAR archive
func (c *Client) ContainerCopyToContainer(ctx context.Context, id string, dstPath string, setters ...copyto.SetContainerCopyToContainerOption) error {
	op := container.CopyToContainerOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return err
			}
		}
	}
	return c.wrapped.CopyToContainer(ctx, id, dstPath, nil, op)
}

// CopyFromContainer gets the content from the container and returns it as a Reader for a
// TAR archive to manipulate it in the host. It's up to the caller to close the reader.
func (c *Client) ContainerCopyFromContainer(ctx context.Context, id string, srcPath string) (io.ReadCloser, *response.ContainerPathStat, error) {
	rc, stat, err := c.wrapped.CopyFromContainer(ctx, id, srcPath)
	if err != nil {
		return nil, nil, err
	}
	return rc, &response.ContainerPathStat{
		PathStat: stat,
	}, nil
}

/*
ContainerAttach attaches a connection to a container in the server. It returns a types.HijackedConnection with the hijacked connection and the a reader to get output. It's up to the called to close the hijacked connection by calling types.HijackedResponse.Close.

The stream format on the response will be in one of two formats:

If the container is using a TTY, there is only a single stream (stdout), and data is copied directly from the container output stream, no extra multiplexing or headers.

If the container is *not* using a TTY, streams for stdout and stderr are multiplexed. The format of the multiplexed stream is as follows:

	[8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}[]byte{OUTPUT}

STREAM_TYPE can be 1 for stdout and 2 for stderr

SIZE1, SIZE2, SIZE3, and SIZE4 are four bytes of uint32 encoded as big endian. This is the size of OUTPUT.

You can use github.com/docker/docker/pkg/stdcopy.StdCopy to demultiplex this stream.
*/
func (c *Client) ContainerAttach(ctx context.Context, id string, setters ...attach.SetContainerAttachOption) (*response.ContainerHijackedResponse, error) {
	op := container.AttachOptions{}
	for _, setter := range setters {
		if setter != nil {
			if err := setter(&op); err != nil {
				return nil, err
			}
		}
	}
	hijacked, err := c.wrapped.ContainerAttach(ctx, id, op)
	if err != nil {
		return nil, err
	}
	return &response.ContainerHijackedResponse{
		HijackedResponse: hijacked,
	}, nil
}
